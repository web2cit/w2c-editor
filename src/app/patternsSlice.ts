import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'
import { PatternConfig } from '../types'
import type { RootState } from './store'
import { Wrapper } from '../wrapper/Wrapper';

// Define a type for the slice state
interface PatternsState {
  patterns: PatternConfig[];
}

// Define the initial state using that type
const initialState: PatternsState = {
  patterns: []
}

export const patternsSlice = createSlice({
  name: 'patterns',
  // `createSlice` will infer the state type from the `initialState` argument
  initialState,
  reducers: {
    add: (state, action: PayloadAction<{ pattern: PatternConfig }>) => {
      
    },
    remove: (state, action: PayloadAction<{ index: number }>) => {
      state.patterns.splice(action.payload.index, 1);
    },
    move: (
      state,
      action: PayloadAction<{ index: number; newIndex: number }>
    ) => {
      const { index, newIndex } = action.payload;
      const pattern = state.patterns.splice(index, 1)[0];
      if (pattern !== undefined) {
        state.patterns.splice(newIndex, 0, pattern);
      };
    },
    update: (
      state,
      action: PayloadAction<{ index: number; pattern: PatternConfig }>
    ) => {
      const { index, pattern } = action.payload;
      state.patterns[index] = pattern;
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(add.pending, (state) => {
        // state.status = 'loading';
      })
      .addCase(add.fulfilled, (state, action) => {
        // mutable updates inside createSlice are converted to immutable updates
        // by Immer

        // todo: how should we deal with fallback pattern
        state.patterns.push(action.payload.pattern);
      })
      .addCase(add.rejected, (state) => {
        // state.status = 'failed';
      });

})

// todo: we don't need to handle loading and rejected states in the global state
// we can just leave this to the component calling the async action
// hence, consider creating a thunk manually instead
export const add = createAsyncThunk<
  // Return type of the payload creator
  { pattern: PatternConfig },
  // First argument to the payload creator
  { pattern: PatternConfig },
  {
    // Optional fields for defining thunkApi field types
    extra: {
      wrapper: Wrapper
    }
  }
>('patterns/add', async ( { pattern }, { extra }) => {
    await extra.wrapper.addPattern(pattern);
    // todo: is it ok to dispatch refresh sorting and outputs here?
    
    // The value we return becomes the `fulfilled` action payload
    return { pattern };
  }
);



// Other code such as selectors can use the imported `RootState` type
export const selectCount = (state: RootState) => state.counter.value

export default counterSlice.reducer

// todo: with this approach we will have two sources of truth: the wrapper
// and the state
// isn't this what happens anyway when we fetch posts from a remote server
// but still keep them locally?


// todo: what is the right place for config metadata? here? or on a separate file?