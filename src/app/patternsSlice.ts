import { AnyAction, createAsyncThunk, createEntityAdapter, createSlice, EntityState, PayloadAction } from '@reduxjs/toolkit'
import { PatternConfig } from '../types'
import type { RootState } from './store'
import { Wrapper } from '../wrapper/Wrapper';
import { ThunkAction } from 'redux-thunk'
import { Root } from 'react-dom/client';
import { ConfigState, ConfigSliceReducers, moveHelper } from "./configSlice";
import { allTargetOutputsExpired, refreshTargets, updateAllTargetOutputs } from "./targetsSlice";
import { batch } from "react-redux";

interface PatternsState extends ConfigState<PatternConfig> {}

// we may want to keep values above as { ids: [], entities: {} }
const patternsAdapter = createEntityAdapter<PatternConfig>({
  // 
  selectId: pattern => pattern.pattern ?? ''
})

// Define the initial state using that type
const initialState: PatternsState = {
  data: patternsAdapter.getInitialState({
    status: 'draft'
  }),
  metadata: {
    revid: null,
    revisions: undefined,
    status: 'idle'
  }
}

// have a function that makes this reducers object
// I'll need to pass it the adapter
const patternsReducers: ConfigSliceReducers<PatternConfig> = {
  add: (state, action) => {
    const { value } = action.payload;
    // I have the state managed by the adapter nested one-level down in the
    // config slice state (i.e., patterns state)
    // Will that be a problem when returning the modified state?
    patternsAdapter.addOne(state.data, value);
  },
  remove: (state, action) => {
    const { index } = action.payload;
    const pattern = state.data.ids[index];
    if (pattern !== undefined) {
      patternsAdapter.removeOne(state.data, pattern);
    };
  },
  move: (state, action) => {
    const { index, newIndex } = action.payload;
    const pattern = state.data.ids[index];
    if (pattern !== undefined) {
      moveHelper<PatternConfig>(state.data, { id: pattern, index: newIndex });
    };
  },
  update: (state, action) => {
    const { index, value } = action.payload;
    const pattern = state.data.ids[index];
    if (pattern !== undefined) {
      patternsAdapter.updateOne(state.data, { id: pattern, changes: value });
    };
  },
  // add loading and error reducers
  revisionsFetched: (state, action) => {
    state.metadata.revisions = action.payload.revisions;
    state.metadata.status = "loaded";
  },
  revisionLoaded: (state, action) => {
    const { revid, values } = action.payload;
    state.metadata.revid = revid;
    state.data.status = 'loaded'
    patternsAdapter.setAll(state.data, values);    
  }
}

export const patternsSlice = createSlice({
  name: 'patterns',
  // `createSlice` will infer the state type from the `initialState` argument
  initialState,
  reducers: patternsReducers,
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(add.pending, (state) => {
        // state.status = 'loading';
      })
      .addCase(add.fulfilled, (state, action) => {
        // mutable updates inside createSlice are converted to immutable updates
        // by Immer

        // todo: how should we deal with fallback pattern
        state.patterns.push(action.payload.pattern);
      })
      .addCase(add.rejected, (state) => {
        // state.status = 'failed';
      });

})

// selectors
export const {
  selectAll: selectAllPatterns,
  selectById: selectPatternByPath,
} = patternsAdapter.getSelectors<RootState>(state => state.patterns.data);

// actions
export const {
  add: patternAdded,
  remove: patternRemoved,
  move: patternMoved,
  update: patternUpdated
} = patternsSlice.actions



// // todo: we don't need to handle loading and rejected states in the global state
// // we can just leave this to the component calling the async action
// // hence, consider creating a thunk manually instead
// export const add = createAsyncThunk<
//   // Return type of the payload creator
//   { pattern: PatternConfig },
//   // First argument to the payload creator
//   { pattern: PatternConfig },
//   {
//     // Optional fields for defining thunkApi field types
//     extra: {
//       wrapper: Wrapper
//     }
//   }
// >('patterns/add', async ( { pattern }, thunkApi) => {
//     await thunkApi.extra.wrapper.addPattern(pattern);
    
//     // about dispatching many actions in a row:
//     // https://redux.js.org/style-guide/#avoid-dispatching-many-actions-sequentially
//     // todo: is it ok to dispatch refresh sorting and outputs here?
    
//     // import actions from corresponding slice files
//     thunkApi.dispatch(refresSort())
//     // thunkApi.dispatch(refreshOutput())  // call from refreshSort...
    
//     // The value we return becomes the `fulfilled` action payload
//     return { pattern };
//   }
// );


// implentation details depend on the config type
// but the shape may be imported from config slice
// thunk action creator
export function addPattern (value: PatternConfig): ThunkAction<
  void,  // have the thunk return a promise so the component dispatching it can know what happened
  RootState,
  Wrapper,
  AnyAction  // what actions can be dispatched from the thunk?
> {
  return async function addPatternThunk (dispatch, _, wrapper) {
    await wrapper.addPattern(value);
    // new template means new path
    // trigger targets refresh
    // and wipe translation outputs (ideally by pattern)
    batch(() => {
      // maybe move these two together out to the targets slice?
      // or even the three
      dispatch(refreshTargets());
      dispatch(allTargetOutputsExpired());
    });

    // and ask for outputs recalculation
    // maybe just for the current selected target
    // maybe updating for current selected target should be automatic in the targets slice
    // i.e., do not update globally if target selected
    // maybe yes respect defined outputs
    dispatch(updateAllTargetOutputs());
    
    // something that the component calling the action may be interested in
    return;
  }
}

const thunkRemove = (path: string): ThunkAction<
  void,
  RootState,
  Wrapper,
  AnyAction
> {
  return async (dispatch, getState, wrapper) {
    await wrapper.removePattern(path);
    dispatch(patternsSlice.actions.remove())
  }
}
  


const fetchRevisions = createAsyncThunk('patterns/revisions/fetch') {
  // ask the wrapper to fetch patterns config revisions

  // can't do this from createAyncThunk helper? dispatch revisionsFetched action

  // if any, ask the wrapper to load the latest revision

  // dispatch revisionLoaded action
}

// Other code such as selectors can use the imported `RootState` type
export const selectCount = (state: RootState) => state.counter.value

export default counterSlice.reducer

// todo: with this approach we will have two sources of truth: the wrapper
// and the state
// isn't this what happens anyway when we fetch posts from a remote server
// but still keep them locally?


// todo: what is the right place for config metadata? here? or on a separate file?