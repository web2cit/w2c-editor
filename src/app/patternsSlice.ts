import { AnyAction, createAsyncThunk, createEntityAdapter, createSlice, EntityId, EntityState, PayloadAction, Update } from '@reduxjs/toolkit'
import { ConfigRevision, PatternConfig } from '../types'
import type { RootState } from './store'
import { Wrapper } from '../api/wrapper';
import { ThunkAction } from 'redux-thunk'
import { Root } from 'react-dom/client';
import { 
  ConfigState,
  ConfigSliceReducers,
  moveHelper,
  AddConfigValueThunkActionCreator,
  RemoveConfigValueThunkActionCreator,
  UpdateConfigValueThunkActionCreator,
  MoveConfigValueThunkActionCreator,
  ConfigRevisionsSelector,
  FetchRevisionsThunkActionCreator
} from "./configSlice";
import { allTargetOutputsExpired, refreshTargets, updateAllTargetOutputs } from "./targetsSlice";
import { batch } from "react-redux";

interface PatternsState extends ConfigState<PatternConfig> {}

// we may want to keep values above as { ids: [], entities: {} }
const patternsAdapter = createEntityAdapter<PatternConfig>({
  // 
  selectId: pattern => pattern.pattern ?? ''
})

// Define the initial state using that type
const initialState: PatternsState = {
  data: patternsAdapter.getInitialState({
    status: 'draft'
  }),
  metadata: {
    revid: null,
    revisions: undefined,
    status: 'idle'
  }
}

// have a function that makes this reducers object
// I'll need to pass it the adapter
const patternsReducers: ConfigSliceReducers<PatternConfig> = {
  add: (state, action) => {
    const { value } = action.payload;
    // I have the state managed by the adapter nested one-level down in the
    // config slice state (i.e., patterns state)
    // Will that be a problem when returning the modified state?
    patternsAdapter.addOne(state.data, value);
    
    // may make this an helper function
    state.data.status = 'draft';
    state.metadata.revid = null;
  },
  remove: (state, action) => {
    const { index } = action.payload;
    const pattern = state.data.ids[index];
    if (pattern !== undefined) {
      patternsAdapter.removeOne(state.data, pattern);
      // may make this an helper function
      state.data.status = 'draft';
      state.metadata.revid = null;
    };
  },
  move: (state, action) => {
    const { index, newIndex } = action.payload;
    const pattern = state.data.ids[index];
    if (pattern !== undefined) {
      moveHelper<PatternConfig>(state.data, { id: pattern, index: newIndex });
      // may make this an helper function
      state.data.status = 'draft';
      state.metadata.revid = null;
    };
  },
  update: (state, action) => {
    const { index, value } = action.payload;
    const pattern = state.data.ids[index];
    if (pattern !== undefined) {
      patternsAdapter.updateOne(state.data, { id: pattern, changes: value });
      // may make this an helper function
      state.data.status = 'draft';
      state.metadata.revid = null;
    };
  },
  // add loading and error reducers
  revisionsFetched: (state, action) => {
    state.metadata.revisions = action.payload.revisions;
    state.metadata.status = "loaded";
  },
  revisionLoaded: (state, action) => {
    const { revid, values } = action.payload;
    state.metadata.revid = revid;
    state.data.status = 'loaded'
    patternsAdapter.setAll(state.data, values);    
  },
  configChanged: (state) => {
    // what should happen if status is "loading"?
    state.data.status = 'draft';
    state.metadata.revid = null;
  }
}

export const patternsSlice = createSlice({
  name: 'patterns',
  // `createSlice` will infer the state type from the `initialState` argument
  initialState,
  reducers: patternsReducers,
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: {
    // alternatively, create action creators for these actions and use the builder syntax
    'patterns/fetchRevisions/pending': (state, action) => {
      state.metadata.status = 'loading';
    },
    'patterns/fetchRevisions/fulfilled': (state, action: PayloadAction<{ revisions: ConfigRevision[] }>) => {
      const { revisions } = action.payload;
      state.metadata.status = 'loaded';
      state.metadata.revisions = revisions;
    },
    // I may not need this reducer
    'patterns/fetchRevisions/rejected': (state) => {
      state.metadata.status = 'idle';
    }
  }
  
  
  // (builder) => {
  //   builder
  //     .addCase(add.pending, (state) => {
  //       // state.status = 'loading';
  //     })
  //     .addCase(add.fulfilled, (state, action) => {
  //       // mutable updates inside createSlice are converted to immutable updates
  //       // by Immer

  //       // todo: how should we deal with fallback pattern
  //       state.patterns.push(action.payload.pattern);
  //     })
  //     .addCase(add.rejected, (state) => {
  //       // state.status = 'failed';
  //     });

})

// selectors
export const {
  selectAll: selectAllPatterns,
  selectById: selectPatternByPath,
} = patternsAdapter.getSelectors<RootState>(state => state.patterns.data);

export const selectPatternRevisions: ConfigRevisionsSelector<RootState> = (state) {
  return state.patterns.metadata.revisions;
}

// actions
export const {
  add: patternAdded,
  remove: patternRemoved,
  move: patternMoved,
  update: patternUpdated,
  configChanged
} = patternsSlice.actions

// todo: note that all add/remove/move/update patterns below folow the same
// shape. they only differ in the wrapper method they use, one of the actions
// they dispatch, and maybe the value they return
// consider having generator of thunk action creators, to avoid repetition
export const addPattern: AddConfigValueThunkActionCreator<RootState, PatternConfig> = function (value) {
  return async function addPatternThunk (dispatch, _, wrapper) {
    await wrapper.addPattern(value);
    // new template means new path
    // trigger targets refresh
    // and wipe translation outputs (ideally by pattern)
    batch(() => {
      // fixme: how do we prevent dispatching multiple actions?
      dispatch(patternAdded({ value }));
      // dispatch(configChanged());
      // maybe move these two together out to the targets slice?
      // or even the three
      dispatch(refreshTargets());
      dispatch(allTargetOutputsExpired());
    });

    // and ask for outputs recalculation
    // maybe just for the current selected target
    // maybe updating for current selected target should be automatic in the targets slice
    // i.e., do not update globally if target selected
    // maybe yes respect defined outputs
    dispatch(updateAllTargetOutputs());
    
    // something that the component calling the action may be interested in
    return;
  }
}

export const removePattern: RemoveConfigValueThunkActionCreator<RootState> = function(id) {
  return async function removePatternThunk (dispatch, _, wrapper) {
    // fixme: as string...
    await wrapper.removePattern(id as string);
    batch(() => {
      // fixme: have the patternRemoved reducer take id instead of index
      dispatch(patternRemoved({ index: 1 }));
      // dispatch(configChanged());
      dispatch(refreshTargets());
      dispatch(allTargetOutputsExpired());
    });
    dispatch(updateAllTargetOutputs());
    return;
  }
}

export const movePattern: MoveConfigValueThunkActionCreator<RootState> = function(id, index) {
  return async function movePatternThunk (dispatch, _, wrapper) {
    // fixme: as string...
    await wrapper.movePattern(id as string, index);
    batch(() => {
      // fixme: have the patternRemoved reducer take id instead of index
      dispatch(patternMoved({ index: 1, newIndex: index }));
      // dispatch(configChanged());
      dispatch(refreshTargets());
      dispatch(allTargetOutputsExpired());
    });
    dispatch(updateAllTargetOutputs());
    return;
  }
};

export const updatePattern: UpdateConfigValueThunkActionCreator<RootState, PatternConfig> = function(id, value) {
  return async function updatePatternThunk (dispatch, _, wrapper) {
    // fixme: as string...
    await wrapper.updatePattern(id as string, value);
    batch(() => {
      // fixme: have the patternUpdated reducer take id instead of index
      // todo: consider passing a changes object instead of value
      dispatch(patternUpdated({ index: 1, value: value}));
      // dispatch(configChanged());
      dispatch(refreshTargets());
      dispatch(allTargetOutputsExpired());
    });
    dispatch(updateAllTargetOutputs());
    return;
  }
};

// I will mimick behavior resulting from createAsyncThunk but not use it
// because I need to batch dispatch multiple actions/thunk actions along with
// the revisionsFetched action

export const fetchRevisions: FetchRevisionsThunkActionCreator<RootState> = () {
  return async function fetchRevisionsThunk(dispatch, _, wrapper) {
    dispatch({type: ""})
  }
}

const fetchRevisions = createAsyncThunk<
  // Return type of the payload creator
  ConfigRevision[],
  // First argument to the payload creator
  undefined,
  {
    // Optional fields for defining thunkApi field types
    extra: {
      wrapper: Wrapper
    }
  }
>
(
  'patterns/revisions',
  async (_, { extra }) => {
    const revisions = await extra.wrapper.fetchConfigRevisions("patterns");
    return revisions;
    await extra.wrapper;
    await thunkApi.extra.wrapper.addPattern(pattern);
    
    // about dispatching many actions in a row:
    // https://redux.js.org/style-guide/#avoid-dispatching-many-actions-sequentially
    // todo: is it ok to dispatch refresh sorting and outputs here?
    
    // import actions from corresponding slice files
    thunkApi.dispatch(refresSort())
    // thunkApi.dispatch(refreshOutput())  // call from refreshSort...
    
    // The value we return becomes the `fulfilled` action payload
    return { pattern };
  }
);('patterns/revisions/fetch') {
  // ask the wrapper to fetch patterns config revisions

  // can't do this from createAyncThunk helper? dispatch revisionsFetched action

  // if any, ask the wrapper to load the latest revision? no, leave this to the
  // component, I guess

  // dispatch revisionLoaded action
}

const loadRevision = createAsyncThunk('patterns/revisions/load') {}

export default patternsSlice.reducer